>> (define a 100)
ここで、
a => 100
となる。
>> (define b 1)
ここで、
b => 1
となる。
>> (let ((a 10) (b (+ a 1)) (c (- b 1)))
ここまでで、
a => 100
b => 1
----------
a => 10
b => 101
c => 0
と、下位の環境が作られる。
>> (let ((a 10) (b (+ a 1)) (c (- b 1)))
ここまでで、
a => 100
b => 1
----------
a => 10
b => 101
c => 0
----------
a => 10
b => 11
c => 100
と、さらに下位の環境が作られる。
>> (+ a b c))))
で、一番下位の環境について和が計算されて、121という出力を得る。
さらに、この評価でlet2つから脱出するので、下の環境2つは破棄され、
a => 100
b => 1
となる。
>> (define h (lambda (x) (lambda (y) (+ x (* a y))
で、hが定義され、環境へのポインタは最上位の環境へのものとなる。
>> (let ((a 1)) ((h 9) 9))
で、
a => 100
b => 1
---------
a => 1
と下位の環境ができるが、hが参照するのは最上位の環境なので関係なく、
909
という出力を得る。ちなみに、このあともう一度defineでaを定義したところ、得る値が変わった。
